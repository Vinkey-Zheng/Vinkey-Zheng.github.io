# C++知识点

1. inline内联函数

inline是C++关键字，在**函数声明或定义中，函数返回类型前加上关键字inline，即可以把函数指定为内联函数**。 这样可以解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题。 关键字inline必须与函数定义放在一起才能使函数成为内联函数，仅仅将inline放在函数声明前面不起任何作用。 inline是一种“用于实现”的关键字，而不是一种“用于声明“的函数。

内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是**直接将整个函数体的代码插人调用语句处**，就像整个函数体在调用处被**重写**了一遍一样。

以时间换取空间，或增加空间消耗来节省时间

2. 冒泡排序：两两之间相互比较，小的那个排在前面

3. 快速排序的时间复杂度最高(nlog2n)，

   冒泡排序、快速排序、

   堆排序、插入排序是不稳定的排序

4. New int 用法：

   int *a = new int(10); //动态创建整型数，无参数是 * a=0，有参数则 * a = 参数
   int *p = new int[10]; //创建一个有10个元素的动态整型数组，没有赋值，元素为随机数
   int *p = new int[10] (); //创建一个有10个元素的动态整型数组，并都赋值为0

5. new、new()和new[]三者的区别

   最近写程序,遇到了new, new()和new[]的三种情况,一时间有点混乱,因此总结如下: 

   + new和new() 
     + new A 来创建一个不确定值的对象或实例,new() 创建一个值为零的对象或实例.而new(X),用于创建一个被初始化为X的对象或实例。
     + 只有当A是POD类型的时候,new A和new A()才会有上面的区别。
       何为POD?POD是plain old data的缩写,它是一个struct或者类,且不包含析构函数以及虚函数。
     + 当不是POD时,有构造函数时,两个都被初始化为零,属于默认构造. 
       没有构造函数是,两个都初始化为一个随机值,且两个值相同. 
       2.new和new[] 
       new 用于单个对象或者实例的创建,就是调用类的构造函数 
       new[]用于创建对象或实例的数组实例,并且地址是连续的 
       释放内存时,new使用 delete,而new[]则对应delete[]

6. 指针：指针也就是内存地址 ，指针变量是用来存放内存地址的变量，不同类型的指针变量所占用的存储单元长度是相同的，而存放数据的变量因数据的类型不同，所占用的存储空间长度也不同。. 有了指针以后，不仅可以对数据本身，也可以对存储数据的变量地址进行操作。

   + 

   + | 定  义       | 含  义                                                       |
     | ------------ | ------------------------------------------------------------ |
     | int *p;      | p 可以指向 int 类型的数据，也可以指向类似 int arr[n] 的数组。 |
     | int **p;     | p 为二级指针，指向 int * 类型的数据。                        |
     | int *p[n];   | p 为指针数组。声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向 int 类型对象的指针 |
     | int (*p)[n]; | 声明一个数组指针，该指针指向一个 int 类型的一维数组。        |
     | int *p();    | p 是一个函数，它的返回值类型为 int *。                       |
     | int (*p)();  | p 是一个函数指针，指向原型为 int func() 的函数。             |

     运算符 “*” 是间接寻址或者间接引用运算符。当它作用于指针时，将访问指针所指向的对象。在上述的声明中： p 是一个指针，保存着一个地址，该地址指向内存中的一个变量； *p 则会访问这个地址所指向的变量。

     指针变量可以进行加减运算，例如`p++`、`p+i`、`p-=i`。指针变量的加减运算并不是简单的加上或减去一个整数，而是跟指针指向的数据类型有关。

     给指针变量赋值时，要将一份数据的地址赋给它，不能直接赋给一个整数，例如`int *p = 1000;`是没有意义的，使用过程中一般会导致程序崩溃。

     使用指针变量之前一定要初始化，否则就不能确定指针指向哪里，如果它指向的内存没有使用权限，程序就崩溃了。对于暂时没有指向的指针，建议赋值`NULL`。

7. C++中指向任意类型的Any类

```c++
在c或者c++中，可以指向任意类型的关键字就是无符号类型void*，任何一个对象都可以使用void*来指向。
class A {
 private：
  int a；
};

class B {
 private：
  char b;
};
 
int i = 10；
A a；
B b；
void* tmp = &i;
tmp = &a;
tmp = &b;
```

1、 在类进入作用域的时候调用构造函数；

2、构造函数没有返回值，因此也不需要在定义构造函数时候声明类型，这是和一般函数的重要区别；

3、构造函数不需要用户调用，也不需要用户调用；

4、函数的函数体不仅可对数据成员赋值，而且可以在构造包含其他语句，但是为了保证程序的清晰，一般不这样做；

5、如果用户没有定义构造函数，系统会默认的生成一个缺省的构造函数，该函数体是空的，没有参数，也不进行初始化操作；

6、调用构造函数时不必给出实参的构造函数，称为默认构造函数（default constructor）。显然，无参的构造函数属于默认构造函数。一个函数只能有一个默认的构造函数

7、一个类可以有多个构造函数，但是在调用的时候，只会更具需要调用其中的一个构造函数。



7. static、const、static const类型成员变量声明和初始化

   + const 定义的常量在超出其作用域之后其空间会被释放，而 static 定义的静态常量在函数执行后不会释放其存储空间。

   + static 表示的是静态的。类的静态成员函数、静态成员变量是和类相关的，而不是和类的具体对象相关的。即使没有具体对象，也能调用类的静态成员函数和成员变量。一般类的静态函数几乎就是一个全局函数，只不过它的作用域限于包含它的文件中。

   ```c++
   class foo{
   public:
       foo();
   private:
   		staticint i;
   };
    
   int foo::i=20;
   ```

   

   + 在 C++ 中，static 静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化，如：**double Account::Rate = 2.25;**
   + static 关键字只能用于类定义体内部的声明中，定义时不能标示为 static。
   + 在 C++ 中，const 成员变量也不能在类定义处初始化，只能通过**构造函数初始化列表**进行，并且必须有构造函数。

   ```c++
   class foo{
   public:
       foo():i(100){}
   private:
       const int i=100;//error!!!
   };
   //或者通过这样的方式来进行初始化
   foo::foo():i(100){}//初始化列表
   ```

   

   + const 数据成员只在**某个对象生存期内是常量**，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其 const 数据成员的值可以不同。所以**不能在类的声明中初始化 const 数据成员**，因为类的对象没被创建时，编译器不知道 const 数据成员的值是什么。
   + const 数据成员的初始化只能在类的构造函数的初始化列表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static cosnt。

   ```c++
   class Test{
     public:
     		Test():a(0){}
         enum {size1=100,size2=200};
     private:
     		const int a;//这里只能声明，只能在构造函数初始化列表中初始化
     		static int b;//不能在类的内部初始化
     		const static int c;//与 static const int c;相同。
   };
     int Test::b=0;//static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象。
     cosnt int Test::c=0;//注意：给静态成员变量赋值时，不需要加static修饰符，但要加cosnt。
   ```

   

8. 类的静态成员函数没有 this 指针，这导致：

   + 不能直接存取类的非静态成员变量，调用非静态成员函数。
   + 不能被声明为 virtual。

9. 静态成员函数 

   静态成员函数没有什么太多好讲的。 

   1.静态成员函数的地址可用普通函数指针储存，而普通成员函数地址需要用类成员函数指针来储存。举例如下： 

   ```c++
   class base{
     	static int func1();
     	int func2();
   };
   int (*pf1)()=&base::func1;//普通的函数指针
   int (base::*pf2)()=&base::func2;//成员函数指针
   ```

   2.静态成员函数不可以调用类的非静态成员。因为静态成员函数不含this指针。 

   3.静态成员函数不可以同时声明为 virtual、const、volatile函数。举例如下：

   ```c++
   class base{
     virtual static void func1();//错误
     static void func2() const;//错误
     static void func3() volatile;//错误
   };
   ```

   最后要说的一点是，静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。

   M的Sum和N的Sum是一样的值，静态成员变量保存值

```c++
#include …
class Myclass{
public:
    Myclass(int a, int b, int c);
    void GetNumber();
    void GetSum();
private:
    int A, B, C;
    static int Sum;
};
 
int Myclass::Sum = 0;
 
Myclass::Myclass(int a, int b, int c){
    A = a;
    B = b;
    C = c;
    Sum += A+B+C;
}
 
void Myclass::GetNumber(){
    cout<<"Number="<<a<<","<<b<<","<<c<<endl;
 }
 
void Myclass::GetSum(){
    cout<<"Sum="<<sum<<endl;
 }
 
void main(){
    Myclass M(3, 7, 10),N(14, 9, 11);
    M.GetNumber();
    N.GetNumber();
    M.GetSum();
    N.GetSum();
}

```



# volatile关键字详解

1. volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：**int volatile vInt;** 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。例如：

   ```c++
   volatile int i=10;
   int a = i;
   ...
   // 其他代码，并未明确告诉编译器，对 i 进行过操作
   int b = i;
   ```

# 
