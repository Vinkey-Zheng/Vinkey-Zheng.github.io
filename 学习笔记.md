# Vinkey-Zheng.github.io
# 各种包

+ npm是node.js打包管理工具，yarn和npm是js管理包

+ pip是python的打包管理工具
+ yum、brew一般用在Mac上面
+ rpm是Linux中的安装文件
+ wget一般是获取相关文件（http。。。。。）
+ Linux Set nu显示行号, set nu!取消行号

#  shell、bash 和 zsh 等词的真正含义

## 解释与编译

编程语言没有编译型和解释型的区别，只能说某个语言常见的执行方式为*编译成新代码执行*或*解释器解释执行*
编译器的输入是A语言的源代码，而输出是B语言；比如C++，被编译成汇编语言；
解释器的输入是A语言的源代码，它直接执行A语言；一般解释器的内部实现是一个编译器加一个虚拟机，编译器把输入语言编译成中间语言，虚拟机直接执行中间语言。

## terminal（终端）

一个程序，是界面上打开的黑框框本身，比如 xterm、kvt 等。shell 运行于其中。

## shell 概念

shell 是一个命令行解释器，顾名思义就是机器外面的一层壳，用于人机交互，只要是人与电脑之间交互的接口，就可以称为 shell。表现为其作用是用户输入一条命令，shell 就立即解释执行一条。不局限于系统、语言等概念、操作方式和表现方式等。 比如我们平时在黑框框里输入命令，叫 command-line interface (CLI)；在屏幕上点点点，叫graphical user interface (GUI)

## Interactive 和 Non-interactive

Interactive，如果你打开 terminal，在里面输入 bash 代码，回车得到输出，你就是在运行一个 Interactive shell，它的特征是可以让用户输入，然后直接把输出打到界面上；如果你运行一个包含了若干行的 shell 脚本，这些 shell 代码就运行在Non-interactive shell 中。

## Login 和 Non-login

login shell 是指登录系统后所获得的顶层 shell，比如最常用的 ssh 登录，登录完后得到一个 login shell
如果已经登录了桌面电脑，打开 terminal 进入的 shell 就是 Non-login shell。

## 类型

常见的 shell 解释器有 sh、bash这两种，其他的 ksh、csh 和 zsh 等是不常见的。Mac OS 中默认安装了以上所有类型，Windows 需要自行安装，Linux 更不用说了。就像上面说的，只要一门语言有解释器，就可以作为 shell 使用。比如Java 有第三方解释器 Jshell，PHP有 PHP Shell。如果你用过 windows，那你对 cmd 这个词一定不陌生，它是 windows shell，官方名称叫做 command interpreter。

## bash

Bash 是最常见的 shell，Mac 中默认 shell 就是 bash。
[bash官网这篇文章]描述了唤起 bash shell 时加载的不同文件：login shell 加载 \~/.bash_profile ，而non-login shell 加载 \~/.bashrc 。

## zsh

很多人的 mac 中会使用 zsh 而不是 bash，一大半是因为 oh-my-zsh 这个配置集，它兼容 bash，还有自动补全等好用的功能。zsh 的配置文件\~/.zshrc

## 配置 shell

如上所说，shell 在启动时都会去找配置文件，然后运行它。你安装的一些脚本，如果想让它能够全局运行，就需要在配置文件中设置路径。有过设置路径后还是不管用的经历吗？多半是因为把配置写在了错误的配置文件里。** 应该在配置shell（最常见的是配置默认命令）之前，使用 echo $SHELL，确认自己现在用的是什么shell后，再去编辑对应的配置文件 **

# Mac终端代理和git代理

## Mac终端代理设置

### 使用ssh代理

1. 临时代理，在终端中输入

```cpp
export http_proxy="http://127.0.0.1:1087"   
export https_proxy="http://127.0.0.1:1087"
或者直接
export all_proxy="http://127.0.0.1:1087"// 这是直接设置了http/https省得麻烦，当然你要是有分开设置的需求就分开设置
```

这是代理本身走的https/http
 或者

```cpp
export http_proxy="socks5://127.0.0.1:1086"   
export https_proxy="socks5://127.0.0.1:1086"
或者
export all_proxy="socks5://127.0.0.1:1086" // 这是直接设置了http/https省得麻烦，当然你要是有分开设置的需求就分开设置
```

这是代理本身走的socks5
 *2.*永久写入
 Mac OS：如果使用的是zsh就在.zshrc中写入

```bash
export http_proxy="http://127.0.0.1:1087"   
export https_proxy="http://127.0.0.1:1087"
或者
export http_proxy="socks5://127.0.0.1:1086"   
export https_proxy="socks5://127.0.0.1:1086"
或者
export all_proxy="socks5://127.0.0.1:1086"
或者
export all_proxy="http://127.0.0.1:1087"
查看代理
env|grep -i proxy
```

Windows端

```shell
set http_proxy="http://127.0.0.1:1087"

set https_proxy="http://127.0.0.1:1087"
```

*3.*取消代理

```php
unset http_proxy // 取消http代理
unset https_proxy // 取消https代理
或者直接全部取消
unset ALL_PROXY
```

*4.*验证代理是否成功（查看公网ip和所在地址）
 终端输入

```css
curl ip.gs
```

5. 查看终端、查看PATH

```cpp
Echo the $Shell
Echo $PATH
```

分支、远程分支

```shell
## 1、在当前分支下（一般是master分支），创建muscleape的本地分支分
$ git checkout -b muscleape
Switched to a new branch 'muscleape'

## 2、将muscleape分支推送到远程
$ git push origin muscleape
Everything up-to-date

## 3、将本地分支muscleape关联到远程分支muscleape上  
$ git branch --set-upstream-to=origin/muscleape
......
......
......
Branch 'muscleape' set up to track remote branch 'muscleape' from 'origin'
或者 
git branch --up-sstream-to iot_vinkey origin/iot_vinkey
## 4、查看本地分支和远程分支的映射关系
$ git branch -vv
muscleape         f938a3d8e9 [origin/muscleape: gone] 测试test

## 5、查看远程分支
$ git branch -r
origin/muscleape

## 6、查看本地各个分支目前最新的提交
$ git branch -v
muscleape         f938a3d8e9 测试test

## 7、查看远程各个分支目前最新的提交
$ git branch -r -v
origin/muscleape         f938a3d8e9 测试test
## 8、查看远程分支
git branch -r
## 9、查看本地分支
git branch
## 10、拉取远程分支
git checkout -b 本地分支 origin/远程分支
## 11、拉取远程分支
git pull origin 远程分支
# 12、拉取分支
git pull
#遇到本地冲突，先删除本地分支，再重新拉取远程分支
git branch -D 本地分支名称
```

### git工作原理

**相关内容**
[git工作原理](https://juejin.cn/post/6844904053370159112)

**内容总结**
git内部一切皆对象，commit对象是git仓库的一个快照，包含了整个项目在某一次提交时所有的文件。

每个version就是一个commit，而虚线框的文件表示不同commit中该文件未做修改，git内部实际上对同一个文件（blob对象）的存储永远只有一份，不同commit中是用对象引用的形式来指向同一文件。

**相关git命令**

- cat：查看文件的内容
- git cat-file -p：查看转化后的内容（某一次commit中的一个文件的具体内容）
- git cat-file -t：查看文件的类型

# Linux中的符号的意义

### Docker的一些基本知识

http://www.dockerinfo.net/document

1. ～：家目录

   ```she l
   cd ~ #回到home目录
   cd ~ user #直接在符号后加上某账户的名称
   ～/bin #路径的一部分
   ```

2. #: 注释作用

3. `:反引号，编程中调用shell命令

4. $：文件行结尾标识符，变量标识符

5. ～+当前的工作目录，这个符号代表当前的工作目录，和内建指令pwd的作用是相同的。

6. ～-上次的工作目录

7. ；连续指令

8. /:代表目录，单一的/代表root根目录的意思

## 查找文件命令

find是根据文件的属性来查找，grep是根据文件的类型来查找

文件属性：文件名、文件大小、修改时间、所有者、所属组、是否为空、访问时间

1. ```shell
   find . //列举该文件夹下面的所有命令
   ```

2. ```shell
   find [完整的路径] -name  “#.t x t" //查找该路径下面以.txt结尾的文件
   ```

3. ```shell
   find 组合查找
   
   基本语法：-a 与（去交集）
   
   ​        -o 或（去并集）
   
   				 -not 非(同-！）
   
   ​				 -！非（同-not)
   find . -name 'file1*' -a -name 'file2*'
   ```

4. 根基文件类型来查找

```shell
find -type f
```

5. 查找关键词

```shell
find . -name  '*srm*' # 在当前目录下查找文件名含有srm的
```



6. 查找文件的后缀

```shell
grep 'test' d* # 显示所有以d开头的文件中包含test的行

grep 'test' aa bb cc # 显示aa, bb , cc的文件中包含test的行

grep '[a-z]\{5\}' aa # 显示aa的文件中所有包含每行字符串至少有5个连续小写字符的字符串的行
grep magic /usr/src # 显示/usr/src目录下的文件（不含子目录）中包含magic的行
grep -r magic /usr/src # 显示/usr/src目录下的文件（包含子目录）中包含magic的行
```

## tail命令

- f 循环读取
- -q 不显示处理信息
- -v 显示详细的处理信息
- -c<数目> 显示的字节数
- -n<行数> 显示文件的尾部 n 行内容
- --pid=PID 与-f合用,表示在进程ID,PID死掉之后结束
- -q, --quiet, --silent 从不输出给出文件名的首部

默认显示最后10行

显示文件 notes.log 的内容，从第 20 行至文件末尾:

```shell
tail -n +20 notes.log
```

显示文件 notes.log 的最后 10 个字符:

```shell
tail -c 10 notes.log
```

```shell
tail -n 100 /etc/cron  #显示最后100行数据
tail -n -100 /etc/cron #除了前99行不显示外，显示第100行到末尾行
```

```shell
tail -n -5 /test001/text001 与 tail -n 5 /test001/text001 
显示的结果相同，均是文件末尾最后 5 行内容。

tail -n +5 /test001/text001 
显示的内容为从第 5 行开始，直到末尾的内容。tail -n 后面的数字有效输入只有单个数字（5）或者加号连接数字（+5）两种。
```

# 底层知识

1. 系统调用：现代操作系统通常让代码运行在两种不同特权的模式下
   ——用户态和内核态——以限制他们的权力。系统调用要操作一些有限的资源，无疑是运行在内核态的。那么用户态程序如何运行内核态的代码呢？操作系统一般是通过中断来从用户态切换到内核态。

2. epoll机制，是一种I/O事件通知机制，实现I/O多路复用。

   + 事件：可读事件（内核缓冲区非空）、可写事件（内核缓冲区不满）

   + 通知机制，就是当事件发生的时候，则主动通知。通知机制的反面，就是轮询机制。

   + epoll的通俗解释

     结合以上三条，epoll的通俗解释是一种当文件描述符的内核缓冲区非空的时候，发出可读信号进行通知，当写缓冲区不满的时候，发出可写信号通知的机制

# C++知识点

1. inline内联函数

inline是C++关键字，在**函数声明或定义中，函数返回类型前加上关键字inline，即可以把函数指定为内联函数**。 这样可以解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题。 关键字inline必须与函数定义放在一起才能使函数成为内联函数，仅仅将inline放在函数声明前面不起任何作用。 inline是一种“用于实现”的关键字，而不是一种“用于声明“的函数。

内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是**直接将整个函数体的代码插人调用语句处**，就像整个函数体在调用处被**重写**了一遍一样。

以时间换取空间，或增加空间消耗来节省时间

2. 冒泡排序：两两之间相互比较，小的那个排在前面

3. 快速排序的时间复杂度最高(nlog2n)，

   冒泡排序、快速排序、

   堆排序、插入排序是不稳定的排序

4. New int 用法：

   int *a = new int(10); //动态创建整型数，无参数是 * a=0，有参数则 * a = 参数
   int *p = new int[10]; //创建一个有10个元素的动态整型数组，没有赋值，元素为随机数
   int *p = new int[10] (); //创建一个有10个元素的动态整型数组，并都赋值为0

5. new、new()和new[]三者的区别

   最近写程序,遇到了new, new()和new[]的三种情况,一时间有点混乱,因此总结如下: 

   + new和new() 
     + new A 来创建一个不确定值的对象或实例,new() 创建一个值为零的对象或实例.而new(X),用于创建一个被初始化为X的对象或实例。
     + 只有当A是POD类型的时候,new A和new A()才会有上面的区别。
       何为POD?POD是plain old data的缩写,它是一个struct或者类,且不包含析构函数以及虚函数。
     + 当不是POD时,有构造函数时,两个都被初始化为零,属于默认构造. 
       没有构造函数是,两个都初始化为一个随机值,且两个值相同. 
       2.new和new[] 
       new 用于单个对象或者实例的创建,就是调用类的构造函数 
       new[]用于创建对象或实例的数组实例,并且地址是连续的 
       释放内存时,new使用 delete,而new[]则对应delete[]

6. 指针：指针也就是内存地址 ，指针变量是用来存放内存地址的变量，不同类型的指针变量所占用的存储单元长度是相同的，而存放数据的变量因数据的类型不同，所占用的存储空间长度也不同。. 有了指针以后，不仅可以对数据本身，也可以对存储数据的变量地址进行操作。

   + 

   + | 定  义       | 含  义                                                       |
     | ------------ | ------------------------------------------------------------ |
     | int *p;      | p 可以指向 int 类型的数据，也可以指向类似 int arr[n] 的数组。 |
     | int **p;     | p 为二级指针，指向 int * 类型的数据。                        |
     | int *p[n];   | p 为指针数组。声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向 int 类型对象的指针 |
     | int (*p)[n]; | 声明一个数组指针，该指针指向一个 int 类型的一维数组。        |
     | int *p();    | p 是一个函数，它的返回值类型为 int *。                       |
     | int (*p)();  | p 是一个函数指针，指向原型为 int func() 的函数。             |

     运算符 “*” 是间接寻址或者间接引用运算符。当它作用于指针时，将访问指针所指向的对象。在上述的声明中： p 是一个指针，保存着一个地址，该地址指向内存中的一个变量； *p 则会访问这个地址所指向的变量。

     指针变量可以进行加减运算，例如`p++`、`p+i`、`p-=i`。指针变量的加减运算并不是简单的加上或减去一个整数，而是跟指针指向的数据类型有关。

     给指针变量赋值时，要将一份数据的地址赋给它，不能直接赋给一个整数，例如`int *p = 1000;`是没有意义的，使用过程中一般会导致程序崩溃。

     使用指针变量之前一定要初始化，否则就不能确定指针指向哪里，如果它指向的内存没有使用权限，程序就崩溃了。对于暂时没有指向的指针，建议赋值`NULL`。

7. C++中指向任意类型的Any类

```c++
在c或者c++中，可以指向任意类型的关键字就是无符号类型void*，任何一个对象都可以使用void*来指向。
class A {
 private：
  int a；
};

class B {
 private：
  char b;
};
 
int i = 10；
A a；
B b；
void* tmp = &i;
tmp = &a;
tmp = &b;
```

1、 在类进入作用域的时候调用构造函数；

2、构造函数没有返回值，因此也不需要在定义构造函数时候声明类型，这是和一般函数的重要区别；

3、构造函数不需要用户调用，也不需要用户调用；

4、函数的函数体不仅可对数据成员赋值，而且可以在构造包含其他语句，但是为了保证程序的清晰，一般不这样做；

5、如果用户没有定义构造函数，系统会默认的生成一个缺省的构造函数，该函数体是空的，没有参数，也不进行初始化操作；

6、调用构造函数时不必给出实参的构造函数，称为默认构造函数（default constructor）。显然，无参的构造函数属于默认构造函数。一个函数只能有一个默认的构造函数

7、一个类可以有多个构造函数，但是在调用的时候，只会更具需要调用其中的一个构造函数。



7. static、const、static const类型成员变量声明和初始化

   + const 定义的常量在超出其作用域之后其空间会被释放，而 static 定义的静态常量在函数执行后不会释放其存储空间。

   + static 表示的是静态的。类的静态成员函数、静态成员变量是和类相关的，而不是和类的具体对象相关的。即使没有具体对象，也能调用类的静态成员函数和成员变量。一般类的静态函数几乎就是一个全局函数，只不过它的作用域限于包含它的文件中。

   ```c++
   class foo{
   public:
       foo();
   private:
   		staticint i;
   };
    
   int foo::i=20;
   ```

   

   + 在 C++ 中，static 静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化，如：**double Account::Rate = 2.25;**
   + static 关键字只能用于类定义体内部的声明中，定义时不能标示为 static。
   + 在 C++ 中，const 成员变量也不能在类定义处初始化，只能通过**构造函数初始化列表**进行，并且必须有构造函数。

   ```c++
   class foo{
   public:
       foo():i(100){}
   private:
       const int i=100;//error!!!
   };
   //或者通过这样的方式来进行初始化
   foo::foo():i(100){}//初始化列表
   ```

   

   + const 数据成员只在**某个对象生存期内是常量**，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其 const 数据成员的值可以不同。所以**不能在类的声明中初始化 const 数据成员**，因为类的对象没被创建时，编译器不知道 const 数据成员的值是什么。
   + const 数据成员的初始化只能在类的构造函数的初始化列表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static cosnt。

   ```c++
   class Test{
     public:
     		Test():a(0){}
         enum {size1=100,size2=200};
     private:
     		const int a;//这里只能声明，只能在构造函数初始化列表中初始化
     		static int b;//不能在类的内部初始化
     		const static int c;//与 static const int c;相同。
   };
     int Test::b=0;//static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象。
     cosnt int Test::c=0;//注意：给静态成员变量赋值时，不需要加static修饰符，但要加cosnt。
   ```

   

8. 类的静态成员函数没有 this 指针，这导致：

   + 不能直接存取类的非静态成员变量，调用非静态成员函数。
   + 不能被声明为 virtual。

9. 静态成员函数 

   静态成员函数没有什么太多好讲的。 

   1.静态成员函数的地址可用普通函数指针储存，而普通成员函数地址需要用类成员函数指针来储存。举例如下： 

   ```c++
   class base{
     	static int func1();
     	int func2();
   };
   int (*pf1)()=&base::func1;//普通的函数指针
   int (base::*pf2)()=&base::func2;//成员函数指针
   ```

   2.静态成员函数不可以调用类的非静态成员。因为静态成员函数不含this指针。 

   3.静态成员函数不可以同时声明为 virtual、const、volatile函数。举例如下：

   ```c++
   class base{
     virtual static void func1();//错误
     static void func2() const;//错误
     static void func3() volatile;//错误
   };
   ```

   最后要说的一点是，静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。

   M的Sum和N的Sum是一样的值，静态成员变量保存值

```c++
#include …
class Myclass{
public:
    Myclass(int a, int b, int c);
    void GetNumber();
    void GetSum();
private:
    int A, B, C;
    static int Sum;
};
 
int Myclass::Sum = 0;
 
Myclass::Myclass(int a, int b, int c){
    A = a;
    B = b;
    C = c;
    Sum += A+B+C;
}
 
void Myclass::GetNumber(){
    cout<<"Number="<<a<<","<<b<<","<<c<<endl;
 }
 
void Myclass::GetSum(){
    cout<<"Sum="<<sum<<endl;
 }
 
void main(){
    Myclass M(3, 7, 10),N(14, 9, 11);
    M.GetNumber();
    N.GetNumber();
    M.GetSum();
    N.GetSum();
}

```



# volatile关键字详解

1. volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：**int volatile vInt;** 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。例如：

   ```c++
   volatile int i=10;
   int a = i;
   ...
   // 其他代码，并未明确告诉编译器，对 i 进行过操作
   int b = i;
   ```

# 软件测试理论知识

## qt4s接口自动化新手入门

QTA是一个兼测试框架和测试平台的工具；

QT4C：面对Windows

QT4A：面对安卓

QT4i：面对IOS

QT4W：面对WEB端

QT4S：面对后台

接口自动化主要是面对后台，所以主要使用QT4S。

## 测试基类

在基类中封装一些通用的方法和操作，测试用例继承此基类，可以复用代码

## 测试用例

1. 用例名采用首字母大写命名法，必须以“Test”结尾，单词尽量少而意义明确，避免使用And、Of这样的连词。
2. 用例每个步骤需要用start_step来描述
3. 

## 软件开发 生命周期

1. SDLC ：需求阶段、设计阶段、建设/发展阶段、测试阶段、部署/交付阶段、维护阶段
2. alpha测试和beta测试的区别

+ **Alpha测试：**Alpha测试（α测试）是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的受控测试，可以在测试现场立刻反馈给开发人员，由开发人员及时分析和处理。**功能,局域化,可使用性,可靠性,性能和支持**

+ **Beta测试：**是软件的多个用户在一个或多个用户的实际使用环境下进行的测试。在Beta测试中，由用户记下遇到的所有问题，包括真实的以及主管认定的，定期向开发者报告，开发者在综合用户的报告后，做出修改，最后将软件产品交付给全体用户使用。**β测试是在开发者无法控制的环境下进行的软件现场应用.**

+ α、β、λ常用来表示软件测试过程中的三个阶段，**α是第一阶段，一般只供内部测试使用**；**β是第二个阶段，已经消除了软件中大部分的不完善之处**，但仍有可能还存在缺陷和漏洞，一般只提供给特定的用户群来测试使用；λ是第三个阶段，此时产品已经相当成熟，只需在个别地方再做进一步的优化处理即可上市发行。

## 软件测试 生命周期

1. STLC: 需求分析：
   + 进入条件：提供应用程序体系结构文档和验收标准
   + 活动行为：列出要执行的所有类型（性能、功能、安全），环境详细、和测试用例的必要工具。
   + 交付成果：列出测试要求和测试环境详细信息的所有必要测试。

2. 测试计划

   + **进入条件**-需求文档活动行为-定义目标依、软件的范围。列出测试的方法
   + **测试环境的解决**。准备测试计划和控制程序。角色和责任的确定。列出测试可交付成果，定义风险(如果有)。

   + **交付成果**-测试策略文档

3. 环境设置
4. 测试用例
5. 缺陷记录
6. 测试周期

## 软件质量保证(也称为QA)

## 软件测试 黑盒测试

1. 决策表技术：电子邮箱和密码登录。电子邮件和密码都是条件，预期结果是操作。在第一个条件下，如果电子邮件和密码都正确，则应将用户定向到帐户的主页。

   在第二种情况下，如果电子邮件正确，但密码不正确，则该功能应显示“密码不正确”。在第三种情况下，如果电子邮件不正确，但密码正确，则应显示“电子邮件不正确”。

2. 边界值分析：它用于测试边界值，因为边界附近的输入值具有较高的误差机会。

3. 状态转化技术：三次试错机会，三次过了，（像账户被锁定，不能登录）

4. 成对测试技术：

## 软件测试 白盒测试

白盒测试又称玻璃盒测试、结构测试、开箱测试和透明盒测试。

透明框或白框或透明框名称表示能够透过软件的外壳进入其内工作。

### 单元覆盖率

1. 新增代码被单元执行覆盖的行数 / 新增代码行数 = 代码覆盖率
   + 在函数A里面新增了一行代码，在代码执行过程中能执行到这一行新增的代码，可以理解为这一行代码被覆盖。
   + 空格、注释目前在计算范围内

### TestBase

1. assert_match和assert_equal的区别是，assert_match使用的是正则匹配而不是严格匹配，比如:

   ```
   self.assert_equal("严格匹配断言", "XXX", "X*")
   ```

   以上的断言是不通过的，但是对于下面的正则断言是通过的:

   ```
   self.assert_match("正则匹配断言", "XXX", "X*")
   ```

   assert_match和assert_equal相比，还有一个区别就是，assert_match只支持字符串或字符串兼容的类型的值的检查；但是assert_equal可以支持大部分类型的值的检查。

   **注解**：对于断言失败的执行逻辑处理，这个是QTA测试框架和其他一般测试框架比较大的差异点，设计测试用例是需要注意。

2. QTA执行用例的接口是先执行run_test，然后执行post_test；而且即使测试用例执行run_test中发生异常，仍会执行post_test，这样就保证了测试环境的清理操作。

QTA会依照以下顺序执行测试用例的三个接口:

> - pre_test
> - run_test
> - post_test

且任意一个接口执行异常，QTA仍然会执行下一个接口。

**注解**

由于历史原因，QTA还提供另一套代码风格的接口preTest、runTest和postTest，建议测试用例编写时选择测试项目存量代码统一的代码风格，如果是新的测试项目还是建议使用lower_with_under的代码风格。

**警告**

在一个测试用例中仅支持一套代码风格的接口，QTA选择接口的代码风格是基于run_test/runTest选择的风格为主，也就是说如果用例定义了runTest，则只会执行preTest和postTest，但不会执行pre_test和post_test。当run_test和runTest两个接口都存在的时候，QTA优先选择run_test接口来执行。

### k8s-pod概念介绍

1. 基本框架
2. 状态介绍

- **节点状态**：即k8s中的pod状态，共包含**Pending、Running、Succeeded、Failed、Unknown**五种状态

  > Pending:
  >
  > > pod 已被 Kubernetes 系统接受，但有一个或者多个容器镜像尚未创建。等待时间包括调度 pod 的时间和通过网络下载镜像的时间。
  >
  > Running
  >
  > > 该 pod 已经绑定到了一个节点上，pod 中所有的容器都已被创建。至少有一个容器正在运行，或者正处于启动或重启状态
  >
  > Succeeded
  >
  > > pod 中的所有容器都被成功终止，并且不会再重启，结束状态
  >
  > Failed
  >
  > > pod 中的所有容器都已终止了，并且至少有一个容器是因为失败终止。也就是说，容器以非0状态退出或者被系统终止
  >
  > Unknown
  >
  > > 因为某些原因无法取得 pod 的状态，通常是因为与 pod 所在主机通信失败

- **容器状态**：即K8s中的container状态，共包含**Waiting、Running、Terminated**三种状态

  > Waiting
  >
  > > 启动到运行中间的一个等待状态，如果长期处于该状态，则需要跟进原因
  >
  > Running
  >
  > > 运行状态
  >
  > Terminated
  >
  > > 终止状态,删除或者异常退出状态

- **进程状态**：容器内的process状态，共包含Active、Inactive、unknown三种状态，

  > Active
  >
  > > 进程存在，依赖服务设置的进程监控，可能有进程监控间隔的间隔
  >
  > Inactive
  >
  > > 进程不存在，依赖服务设置的进程监控，可能有进程监控间隔的间隔

- > unknown
  >
  > > 服务未下发进程监控任务<原因可能是扩容，发布时执行start/stop脚本返回非0>

- **服务状态**：最终的结果状态，也体现在service状态上，共包含healthy/unhealthy/unknown等状态，

  > 依赖平台从北极星查到的service状态，如果服务service在北极星侧没有注册则为unknown;
  >
  > 123平台上的trpc服务默认全部开启healthy检测
  >
  > 123平台上的trpc服务默认三秒上报一次状态，三轮未上报则为unhealthy
  > 界面详细状态展示
  界面的详细状态展示会按照前面的图从左到右依次细致化，当底层出现问题时，优先展示底层状态：例如当pod创建成功，container正处于创建中，则整体状态展示为：Waiting。
